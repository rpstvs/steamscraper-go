// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: price.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const addPrice = `-- name: AddPrice :many
INSERT INTO Prices (PriceDate, Item_id, Price)
VALUES ($1, $2, $3)
RETURNING pricedate, item_id, price
`

type AddPriceParams struct {
	Pricedate time.Time
	ItemID    uuid.UUID
	Price     float64
}

func (q *Queries) AddPrice(ctx context.Context, arg AddPriceParams) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, addPrice, arg.Pricedate, arg.ItemID, arg.Price)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(&i.Pricedate, &i.ItemID, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemRecord = `-- name: GetItemRecord :many
Select Price
FROM Prices
WHERE Item_id = $1
ORDER By PriceDate DESC
LIMIT $2
`

type GetItemRecordParams struct {
	ItemID uuid.UUID
	Limit  int32
}

func (q *Queries) GetItemRecord(ctx context.Context, arg GetItemRecordParams) ([]float64, error) {
	rows, err := q.db.QueryContext(ctx, getItemRecord, arg.ItemID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []float64
	for rows.Next() {
		var price float64
		if err := rows.Scan(&price); err != nil {
			return nil, err
		}
		items = append(items, price)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsRecord = `-- name: GetItemsRecord :many
SELECT Itemname,
    Id,
    CAST (Prices.Price AS NUMERIC(10, 2))
FROM Items
    LEFT JOIN Prices ON Items.Id = Prices.Item_id
WHERE Itemname = $2
ORDER BY PriceDate DESC
Limit $1
`

type GetItemsRecordParams struct {
	Limit    int32
	Itemname string
}

type GetItemsRecordRow struct {
	Itemname    string
	ID          uuid.UUID
	PricesPrice float64
}

func (q *Queries) GetItemsRecord(ctx context.Context, arg GetItemsRecordParams) ([]GetItemsRecordRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemsRecord, arg.Limit, arg.Itemname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsRecordRow
	for rows.Next() {
		var i GetItemsRecordRow
		if err := rows.Scan(&i.Itemname, &i.ID, &i.PricesPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPrice = `-- name: GetLatestPrice :one
SELECT Price,
    Item_id
FROM Prices
WHERE Item_id = $1
ORDER BY PriceDate DESC
`

type GetLatestPriceRow struct {
	Price  float64
	ItemID uuid.UUID
}

func (q *Queries) GetLatestPrice(ctx context.Context, itemID uuid.UUID) (GetLatestPriceRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestPrice, itemID)
	var i GetLatestPriceRow
	err := row.Scan(&i.Price, &i.ItemID)
	return i, err
}

const getPrice = `-- name: GetPrice :one
SELECT CAST (Prices.Price AS NUMERIC(10, 2))
FROM Items
    LEFT JOIN Prices ON Items.Id = Prices.Item_id
WHERE Itemname = $1
ORDER BY PriceDate DESC
`

func (q *Queries) GetPrice(ctx context.Context, itemname string) (float64, error) {
	row := q.db.QueryRowContext(ctx, getPrice, itemname)
	var prices_price float64
	err := row.Scan(&prices_price)
	return prices_price, err
}

const getPricebyId = `-- name: GetPricebyId :many
SELECT Price,
    PriceDate
FROM Prices
WHERE Item_id = $1
ORDER BY PriceDate DESC
`

type GetPricebyIdRow struct {
	Price     float64
	Pricedate time.Time
}

func (q *Queries) GetPricebyId(ctx context.Context, itemID uuid.UUID) ([]GetPricebyIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPricebyId, itemID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPricebyIdRow
	for rows.Next() {
		var i GetPricebyIdRow
		if err := rows.Scan(&i.Price, &i.Pricedate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
