// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: price.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addPrice = `-- name: AddPrice :many
INSERT INTO Prices (PriceDate, item_classid, Price)
VALUES ($1, $2, $3)
RETURNING pricedate, item_classid, price
`

type AddPriceParams struct {
	Pricedate   time.Time
	ItemClassid int64
	Price       float64
}

func (q *Queries) AddPrice(ctx context.Context, arg AddPriceParams) ([]Price, error) {
	rows, err := q.db.QueryContext(ctx, addPrice, arg.Pricedate, arg.ItemClassid, arg.Price)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Price
	for rows.Next() {
		var i Price
		if err := rows.Scan(&i.Pricedate, &i.ItemClassid, &i.Price); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemRecord = `-- name: GetItemRecord :many
Select Price
FROM Prices
WHERE item_classid = $1
ORDER By PriceDate DESC
LIMIT $2
`

type GetItemRecordParams struct {
	ItemClassid int64
	Limit       int32
}

func (q *Queries) GetItemRecord(ctx context.Context, arg GetItemRecordParams) ([]float64, error) {
	rows, err := q.db.QueryContext(ctx, getItemRecord, arg.ItemClassid, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []float64
	for rows.Next() {
		var price float64
		if err := rows.Scan(&price); err != nil {
			return nil, err
		}
		items = append(items, price)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getItemsRecord = `-- name: GetItemsRecord :many
SELECT Itemname,
    item_classid,
    CAST (Prices.Price AS NUMERIC(10, 2))
FROM Items
    LEFT JOIN Prices ON Items.Id = Prices.Item_id
WHERE Itemname = $2
ORDER BY PriceDate DESC
Limit $1
`

type GetItemsRecordParams struct {
	Limit    int32
	Itemname string
}

type GetItemsRecordRow struct {
	Itemname    string
	ItemClassid sql.NullInt64
	PricesPrice float64
}

func (q *Queries) GetItemsRecord(ctx context.Context, arg GetItemsRecordParams) ([]GetItemsRecordRow, error) {
	rows, err := q.db.QueryContext(ctx, getItemsRecord, arg.Limit, arg.Itemname)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetItemsRecordRow
	for rows.Next() {
		var i GetItemsRecordRow
		if err := rows.Scan(&i.Itemname, &i.ItemClassid, &i.PricesPrice); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestPrice = `-- name: GetLatestPrice :one
SELECT Price,
    item_classid
FROM Prices
WHERE item_classid = $1
ORDER BY PriceDate DESC
`

type GetLatestPriceRow struct {
	Price       float64
	ItemClassid int64
}

func (q *Queries) GetLatestPrice(ctx context.Context, itemClassid int64) (GetLatestPriceRow, error) {
	row := q.db.QueryRowContext(ctx, getLatestPrice, itemClassid)
	var i GetLatestPriceRow
	err := row.Scan(&i.Price, &i.ItemClassid)
	return i, err
}

const getPricebyId = `-- name: GetPricebyId :many
SELECT Price,
    PriceDate
FROM Prices
WHERE item_classid = $1
ORDER BY PriceDate DESC
`

type GetPricebyIdRow struct {
	Price     float64
	Pricedate time.Time
}

func (q *Queries) GetPricebyId(ctx context.Context, itemClassid int64) ([]GetPricebyIdRow, error) {
	rows, err := q.db.QueryContext(ctx, getPricebyId, itemClassid)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetPricebyIdRow
	for rows.Next() {
		var i GetPricebyIdRow
		if err := rows.Scan(&i.Price, &i.Pricedate); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
